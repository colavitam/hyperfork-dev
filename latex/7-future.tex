\section{Future Work} \label{sec:future}

\Paragraph{Current Limitations} While our current HyperFork implementation provides a
reliable fork primitive for our basic benchmarks, it has several limitations
that would need to be addressed before production deployment. Currently, only
read-only root filesystems are supported. Read-write filesystems can cause
corruption when multiple forked virtual machines have contradictory state. We
observed this several times in practice. This could be addressed by adding an
overlay layer to the block device driver that stores writes to the file system
in VMM memory instead of persisting them to disk, making writes from different
virtual machines invisible to each other.

We have not added support for all of kvmtool's devices to Hyperfork.
Specifically, the network device and virtio balloon device are not
supported. Additionally, kvmtool has an outstanding bug in its terminal
emulation that manifests in degraded performance after forking. We have worked
around this in our current implementation.

Furthermore, there is an outstanding race condition in the kvm-clock feature, a
paravirtualized clock accessible from the guest virtual machine. This manifests
itself as occasional non-monotonicity in the guest, causing prolonged
kernel-level stalls in the guest virtual machine. For our tests, we have
disabled kvm-clock to avoid these problems. We suspect it can be resolved by
careful adjustment of the clock when restoring virtual machine state.

\Paragraph{Additional Research}

% TODO: maybe change this into paragraphs? Bullets don't really match the rest of the paper
\begin{itemize}
  \item HyperFork currently does not handle very many devices. A deployable HyperFork would need to re-initialize and re-configure network state post-fork. We also assume in our implementation that the guest is running entirely from a RAM filesystem. If any external virtual or physical disks were in use, then HyperFork would need to address synchronization concerns with those devices.
  \item Currently, HyperFork operates entirely in userspace by serializing all KVM state pre-fork and then recreating it post-fork. We suspect that a kernel-mode implementation may offer further performance benefits. This avoids the overhead of copying KVM state into userpace and then back into the kernel, instead just passing the state directly between the KVM backing structures for the parent and child processes.
  \item There are several serious security concerns with cloning Virtual Machines in production. ASLR and KASLR are defeated, since the guest memory is copied exactly. It is also not desirable for two guest VMs to share a source of randomness, so any random generators would need to be re-seeded in the child VM.
  \item Firecracker boasts significant boot time improvements over existing hypervisor solutions. In our experiments we discovered that the configuration of the guest kernel can also affect boot times by an order of magnitude. We therefore would like to investigate whether Firecracker's performance improvements come from its inherent design and implementation or if it gains these benefits primarily by using stripped-down guest kernels and filesystem images.
\end{itemize}
